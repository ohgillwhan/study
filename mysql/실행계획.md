# 실행계획
## 실행계획이란?
하나의 쿼리문이 결과를 도출해내는 방법에는 여러가지가 있다.  
실행계획에는 쿼리문이 실행하는 계획이 적혀 있으며 통계정보를 활용을 한다.  
통계정보에는 데이터 건수가 몇건이 있고, 인덱스에 있는 유니크값이 몇개가 있는지 보관을 한다.  
## 통계정보란?
예를들어 1억건의 데이터가 실제로 존재하는데 통계정보에는 10건만 있다고 판단하여 풀스캔 하면은 1분안에 끝날것이 1시간이 걸리게 된다.  
이런식으로 통계정보에는 부정확한경우가 있다.  
특히 데이터가 적으면은 부정확해지며 이것을 analyze 명령어를 쓰면은 데이터건수를 다시 수집을한다.  
## explain
실행계획을 분석하는 방법은 explain 명령어를 사용하는것이다.
### id컬럼
SELECT 밑에는 SUBQUERY가 존재할 수 있다.  
같은 레벨에 있는 SELECT는 (조인 등) 같은 Id가 부여되고, 서브쿼리는 다른 Id가 제공된다.
  
### select 컬럼
어떤 타입의 쿼리인지 표시한다.  
#### simple
union, subquery를 사용하지 않은 단순한 select 쿼리.  
#### primary
union이나 subquery가 포함된 쿼리이며 가장 바깥쪽에 있는 단위 쿼리.  
#### union 
##### union
union으로 결합하는 쿼리중 첫번째를 제외한 나머지는 union이라 표시된다.
##### dependent union
union이랑 같은 쿼리지만 바깥에 있는 쿼리의 데이터를 사용시 dependent union이다.  
##### union result
union 결과를 담아두는 테이블이다. id가 부여되지 않으며 union result<N,M,...> 이 표시되는데 N,M,...이 합쳐진 union_result이다.
##### uncacheable union
캐시하지 못하는 union 타입.    
#### subquery
##### subquery
from절에 없는 subquery.  
from절에 있는 subquery는 derived라는 것으로 표시된다.  
##### dependent subquery
바깥쪽 쿼리에 의존하는 subquery
##### uncaheable subquery
쿼리에 하나의 서브쿼리는 한번만 실행되는게 아니고 쿼리 로직상 여러번 실행이 된다.  
이럴때는 캐쉬에 저장하게 된다.  
하지만 저장하지 못하는 경우는 dependent subquery 또는 변수를 사용할때다.  
#### derived  
서브쿼리가 from절에 사용될경우 derived라는 것으로 실행한다.  
이것은 메모리 / 디스크에 임시 테이블을 생성하며 인덱스가 없으므로 조인시 성능상 불리할때가 있다.  

### table 컬럼
실행계획은 쿼리 기준이 아니라 테이블 기준으로 표시되며 별칭이 부여되면 별칭으로 표시된다.  
<derived> <union> 같이 <> 로 표시된것은 임시 테이블이다.  
<> 뒤에 붙는 순자는 select 쿼리의 id를 지칭한다.  
예를들어  

|id|select_type|table|
|---|----|----|
|1|PRIMARY|\<derived2\>|
|1|PRIMARY|e|
|2|DERIVED|dept_emp|  

일경우 1번의 derived2는 2번을 가르키는것이며 쿼리로 나타낼경우 아래로 추측이 가능하다.  
```sql
SELECT  *
FROM    (SELECT de.emp_no FROM dept_emp de) tb
    ,   employees e
WHERE   e.emp_no = tb.emp_no;
```

### type 컬럼  
테이블의 레코드를 어떤 방식으로 읽었는지 나타낸다.  
인덱스를 사용했는지 풀 테이블 스캔으로 읽었는지이다.  
ALL을 제외한 나머지 방법은 인덱스를 사용해서 데이터를 가져온것이다.  
#### system
테이블에 1건 or 0건 존재할경우 나타나며 innodb에서는 나타나지 않는다.  
#### const
pk 또는 uk 칼럼을 이용해서 반드시 1건만 가져올 경우 const방식이다.  
#### eq_ref
여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다.  
첫번째 테이블에서 가져온 column으로 두번째 테이블에 있는 pk 또는 uk와 조인할 경우  
두번째 테이블에 eq_ref가 표시된다.  
그리고 반드시 한건만 존재해야 한다.  
#### ref
eq_ref처럼 테이블 순서와 상관이 없으며 pk, uk 조건도 없다.  
인덱스의 종류와 관계없이 동등 조건으로 검색할 때는 ref가 걸린다.  
#### fulltext
전문검색이며 상황에 따라 속도의 우선순위는 바뀐다.  
#### ref_or_null
ref 접근 방식과 같은데 null 비교가 추가된것이다.  
is null을 추가하면은 ref_or_null이 된다.  
#### unique_subquery
where 조건절에 있는 in 쿼리를 위한 접근 방식이다.  
unique_subquery 는 중복되지 않는 유니크한 값만 반환할때 이 접근 방법을 사용한다.  
***in 형태의 조건에서 subquery의 반환 값에는 중복이 없으므로 제거 작업이 필요하지 않음***  
#### index_subquery
in(subquery, 상수) 형태의 조건은 중복된 값이 먼저 제거되어야 한다.  
unique_subquery는 중복값이 없다는 보장으로 제거하지 않았지만 중복된 값이 반환할 수 있지만 인덱스를 통해 제거될 수 있으면 index_subquery 접근이 된다.
예를들어 A_KEY+B_KEY 두개로 복합키가 이뤄져 있을경우 A_KEY는 여러개가 될 수 있다.  
이럴경우에는 index_subquery가 탄다    
***in 형태의 조건에서 subquery의 반환 값에는 중복값이 있을 수 있지만 인덱스를 통해 제거가 가능***  
#### range  
범위검색을 할 경우 사용된다.  
<, > , IS NULL, BETWEEN, IN, LIKE 등에서 사용된다.  
#### index_merge
index_merge 접근 방식은 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어 낸 후 결과를 병합하는 처리 방식이다.  
비효율 적이다.  
OR 같은것으로 조건검색할 경우가 해당된다.  
#### index
index는 자주 오해하는 접근 방식이다.  
index라고 해서 효율적이라고 생각하면 안된다.
조건절이 없이 order by를 하거나 이럴경우 해당이된다.    
#### ALL
풀 테이블 스캔이다.  

### possible_keys 컬럼  
사용될 법했던 인덱스의 목록

### key 컬럼
possible_keys 컬럼은 후보 목록이지만 key는 최종선택된 인덱스.  
index_merge의 경우에는 ,로 구분된다.  

### key_len 컬럼
단일 컬럼보단 다중 컬럼으로 만들어진 인덱스를 이용하는경우가 많다.  
쿼리를 처리하기 위해 다중컬럼으로 구성된 인덱스에서 몇개의 컬럼까지 사용했는지 우리에게 알려준다. ( 정확히는 길이 )  
dept_no과 emp_no가 복합키일경우  
select * from dept where dept_no = 'aaaa'; 일경우 12이지만  
select * from dept where dept_no = 'aaaa' and emp_no = 'bbbb'; 일경우는 16이 나온다.

### ref 컬럼
접근 방법이 ref 방식이면 참조 조건 (equal 비교 조건)이 어떤 값이 제공됬는지 보여준다.  
#### const
상수를 동등식 할경우 const로 표시된다.  
#### 테이블.컬럼
테이블의 값을 가져올경우 테이블.컬럼으로 표시된다
#### func
컬럼에서 값을 수정하거나 그런 행동을 했을경우 func로 표시된다.  
(de.emp_no-1)등..  

### rows 컬럼
실행계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다.  
정확하지 않으므로 무시하는게 좋다.
  
### extra 컬럼  
쿼리의 실행 계획에서 성능에 관련하여 중요한 내용이 자주 나오는 컬럼이다.  
#### const row not found
const 접근 방식으로 테이블에 접근했지만 데이터가 없을경우.  
#### distinct
distinct 키워드가 추가될경우 나타난다  
#### full scan on null key
col1 in (select col2 from ...) 시 col1이 null일경우 full scan이 실행된다.  
col1이 not null일경우는 상관이 없다.  
col1 is not null 조건문을 넣어도 괜찮다.  
#### impossible having
having절의 조건을 만족하는 레코드가 없을 때 표시된다.  
예를들어 having e.emp_no is null시 emp_no은 pk면서 notull일경우 해당 키워드가 표시된다.  
***이것이 표출되면은 쿼리문이 잘못될 가능성이 높으니 확인해야 한다.***
